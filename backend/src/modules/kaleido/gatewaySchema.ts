/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/": {
    /**
     * Webhook for async transactions 
     * @description <h3>Send a simple JSON or YAML payload that can:</h3>
     * <ul>
     *   <li>Compile and deploy contracts from in-line Solidity source code</li>
     *   <li>Deploy contracts from bytecode</li>
     *   <li>Asynchronously deliver transactions to your ethereum node over our Kafka backbone</li>
     *   <li>Invoke solidity transactions without needing to first install an ABI</li>
     * </ul>
     * <p>
     *   You get a response <b>immediately</b>, including an <code>id</code> that you can query for results
     *   in the receipt store later.
     * </p>
     * <blockquote>
     *   The same reliable transport as is used on <code>POST</code> methods of the installed REST Gateway
     *   generated interfaces (installed via the <code>/abis</code> paths), when <code>kld-sync</code> is unset.
     * </blockquote>
     * <p>
     *   Ideal for use as a webhook endpoint for an integration tool that can emit sevents over HTTPS.
     *   Also useful if your application wants to construct the full details for the transaction to sent
     *   to a contract, or install a new contract, without first teaching the REST API Gateway about the
     *   Solidity interface (ABI).
     * </p>
     * <p>
     *   There are two variations of the webhook:
     *   <ul>
     *     <li>Fire &amp; forget on <code>/</code> and <code>/fasthook</code>: responds as soon as the message is sent to the Kafka client library</li>
     *     <li>Kafka acknowledged on <code>/hook</code>: responds only once Kafka has acknowledged receipt of the message
     *   </ul>
     * </p>
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["EthconnectWebhookRequest"];
          "application/x-yaml": components["schemas"]["EthconnectWebhookRequest"];
        };
      };
      responses: {
        /** @description Webhook acknowledgement */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectWebhookResponseAck"];
          };
        };
      };
    };
  };
  "/fasthook": {
    /**
     * Fire & forget webhook 
     * @description Responds as soon as the message is passed to the Kafka client library.
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["EthconnectWebhookRequest"];
          "application/x-yaml": components["schemas"]["EthconnectWebhookRequest"];
        };
      };
      responses: {
        /** @description Webhook acknowledgement */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectWebhookResponseFast"];
          };
        };
      };
    };
  };
  "/hook": {
    /**
     * Kafka acknowledged webhook 
     * @description Waits for an acknowledgment from Kafka that the message has been delivered to a topic partition before responding.<br/>
     * Recommended when reliable transaction delivery is required.
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["EthconnectWebhookRequest"];
          "application/x-yaml": components["schemas"]["EthconnectWebhookRequest"];
        };
      };
      responses: {
        /** @description Webhook acknowledgement (with Kafka ack) */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectWebhookResponseAck"];
          };
        };
      };
    };
  };
  "/abis": {
    /**
     * List contract REST APIs 
     * @description List the previously installed ABI definitions with available factory, query & event-subscription REST APIs
     */
    get: {
      responses: {
        /** @description Installed ABI definition */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectABIs"];
          };
        };
      };
    };
    /**
     * Add new contract REST API 
     * @description <p>
     *   Compiles the supplied Solidity source code into an ABI (and devdocs) from a single file or zip/tarball,
     *   then builds a new REST API that can then be used:</p>
     * <ul>
     *   <li>To query data from any existing contract deployed on-chain</li>
     *   <li>As a factory to deploy contract instances on-chain</li>
     *   <li>To subscribe for events matching the signatures defined in the Solidity source code</li>
     *   <li>To install a friendly named API onto this node that binds a friendly API to an individual smart contract</li>
     * </ul>
     * <p>
     *   As there are a number of functions performed by the installed REST API, and the paths are all bespoke
     *   to the methods in the Solidity itself, the installed API comes with its own OpenAPI 2.0 (Swagger) definition.
     * </p>
     * <blockquote>
     *   A link to the generated API definition is included in the response payload.
     * </blockquote>
     * <p>
     *   As the primary input is file data the Content-Type for the payload on route is
     *   <code>multipart/form-data</code>, rather than JSON.
     * </p>
     */
    post: {
      requestBody?: {
        content: {
          "multipart/form-data": components["schemas"]["EthconnectNewContractFormData"];
        };
      };
      responses: {
        /** @description Installed ABI definition */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectABI"];
          };
        };
      };
    };
  };
  "/abis/{abi_id}": {
    /**
     * Get contract REST API 
     * @description List details of a single previously installed ABI definitions with a factory, query & event-subscription REST API
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the install ABI */
          abi_id: string;
        };
      };
      responses: {
        /** @description Installed ABI definition */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectABI"];
          };
        };
      };
    };
  };
  "/contracts": {
    /**
     * List contract instance APIs 
     * @description List the previously installed ABI definitions with available REST APIs
     */
    get: {
      responses: {
        /** @description Installed ABI definition */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectABIs"];
          };
        };
      };
    };
  };
  "/contracts/{contract_address_or_friendly_name}": {
    /**
     * Get contract instance API 
     * @description List the previously installed ABI definitions with available REST APIs
     */
    get: {
      parameters: {
        path: {
          /** @description The ID of the install ABI */
          contract_address_or_friendly_name: string;
        };
      };
      responses: {
        /** @description Installed ABI definition */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectABI"];
          };
        };
      };
    };
  };
  "/eventstreams": {
    /**
     * List Event Streams 
     * @description Returns a list of all event streams registered on this node
     */
    get: {
      responses: {
        /** @description Event streams */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectEventStreams"];
          };
        };
      };
    };
    /**
     * Add Event Stream 
     * @description Add a new event stream, to which subscriptions can deliver messages
     */
    post: {
      requestBody?: {
        content: {
          "application/json": components["schemas"]["EthconnectEventStreamCreate"];
        };
      };
      responses: {
        /** @description Event stream */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectEventStream"];
          };
        };
      };
    };
  };
  "/eventstreams/{stream_id}": {
    /**
     * Get Event Stream 
     * @description Get the details of an individual event stream
     */
    get: {
      parameters: {
        path: {
          stream_id: components["parameters"]["EthconnectStreamID"];
        };
      };
      responses: {
        /** @description Event streams */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectEventStream"];
          };
        };
      };
    };
    /**
     * Delete Event Stream 
     * @description Delete an event stream, and any registered subscriptions
     */
    delete: {
      parameters: {
        path: {
          stream_id: components["parameters"]["EthconnectStreamID"];
        };
      };
      responses: {
        /** @description Success */
        204: never;
      };
    };
    /**
     * Update Event Stream 
     * @description Update the details of an individual event stream
     */
    patch: {
      parameters: {
        path: {
          stream_id: components["parameters"]["EthconnectStreamID"];
        };
      };
      responses: {
        /** @description Event streams */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectEventStream"];
          };
        };
      };
    };
    parameters: {
      path: {
        stream_id: components["parameters"]["EthconnectStreamID"];
      };
    };
  };
  "/eventstreams/{stream_id}/suspend": {
    /**
     * Suspend a stream 
     * @description Stops event delivery on an Event Stream, while retaining state of the events delivered so far
     */
    post: {
      parameters: {
        path: {
          stream_id: components["parameters"]["EthconnectStreamID"];
        };
      };
      responses: {
        /** @description Success */
        204: never;
      };
    };
    parameters: {
      path: {
        stream_id: components["parameters"]["EthconnectStreamID"];
      };
    };
  };
  "/eventstreams/{stream_id}/resume": {
    /**
     * Resume a stream 
     * @description Resumes delivery on an Event Stream that was previously suspended
     */
    post: {
      parameters: {
        path: {
          stream_id: components["parameters"]["EthconnectStreamID"];
        };
      };
      responses: {
        /** @description Success */
        204: never;
      };
    };
    parameters: {
      path: {
        stream_id: components["parameters"]["EthconnectStreamID"];
      };
    };
  };
  "/subscriptions": {
    /**
     * List Subscriptions 
     * @description Returns a list of all subscriptions registered on this node
     */
    get: {
      responses: {
        /** @description Subscriptions */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectSubscriptions"];
          };
        };
      };
    };
  };
  "/subscriptions/{subscription_id}": {
    /**
     * Get Subscription 
     * @description Returns details of an individual subscription
     */
    get: {
      parameters: {
        path: {
          subscription_id: components["parameters"]["EthconnectSubscriptionID"];
        };
      };
      responses: {
        /** @description Subscription */
        200: {
          content: {
            "application/json": components["schemas"]["EthconnectFullSubscription"];
          };
        };
      };
    };
    /**
     * Delete Subscription 
     * @description Deletas a subscription
     */
    delete: {
      parameters: {
        path: {
          subscription_id: components["parameters"]["EthconnectSubscriptionID"];
        };
      };
      responses: {
        /** @description Success */
        204: never;
      };
    };
    parameters: {
      path: {
        subscription_id: components["parameters"]["EthconnectSubscriptionID"];
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    Error: {
      errorMessage?: string;
    };
    EthconnectWebhookRequest: {
      /** @description Headers section used in requests, and extended in asynchronous response messages */
      headers: {
        /**
         * @description The type of action to perform 
         * @enum {string}
         */
        type: "DeployContract" | "SendTransaction";
      };
      /** @description The address to use when signing the transaction. Must be a wallet managed by Kaleido. For example account[0] on the node. */
      from: string;
      /** @description <code>SendTransaction</code> only: The contract address to send the transaction too. */
      to?: string;
      /** @description <code>SendTransaction</code> only: The method name to invoke on the target contract. */
      methodName?: string;
      /** @description The parameters to pass to the ethereum method or constructor. */
      params?: ({
          /** @description The solidity type of the paramter, such as 'uint256' or 'bytes32'. Supplying this with the simple webhook payload allows invocation of contracts without requiring a full ABI. */
          type?: string;
          /** @description The value to pass to the parameter (optionally supply a number or boolean rather than a string, depending on the Solidity type and precision required) */
          value?: string;
        })[];
      /** @description <code>DeployContract</code> only: Soldity source code to compile. */
      soldity?: string;
      /** @description <code>DeployContract</code> only: When there are multiple contracts in the compiler output, this field is required to select the contract to deploy. */
      contractName?: string;
      /**
       * @description <code>DeployContract</code> only: solc compiler version to use. Only the major version is used in the supplied semver, such as <code>0.4</code> or <code>0.5</code>. 
       * @default 0.4
       */
      compilerVersion?: string;
      /**
       * Format: byte 
       * @description <code>DeployContract</code> only: Pre-compiled base64 encoded byecode - alternative to supplying Solidity code for compilation.
       */
      compiled?: string;
      /** @description The maximum gas the transaction can consume - omit to allow ethconnect to perform a gas estimation */
      gas?: string;
      /** @description The ETH price offered for gas - omit to use a gas price of zero */
      gasPrice?: string;
      /** @description An optional ETH value to send along with the tranaction */
      value?: string;
      /** @description Assign an explicit nonce to the transaction - omit to allow ethconnect to manage the nonce */
      nonce?: string;
      /** @description EEA privacy extensions privateFrom address for private transaction support (Quorum Tessera / PegaSys Orion) */
      privateFrom?: string;
      /** @description EEA privacy extensions privateFor addresses for private transaction support (Quorum Tessera / PegaSys Orion) */
      privateFor?: (string)[];
    };
    EthconnectWebhookResponseFast: {
      /** @description Request identifier to use when querying for transaction results in the receipt store */
      id?: string;
      /** @description Whether the request was successfully sent to the Kafka reliable delivery transport - no acknowledgement is obtained */
      sent?: boolean;
    };
    EthconnectWebhookResponseAck: {
      /** @description Request identifier to use when querying for transaction results in the receipt store */
      id?: string;
      /** @description Whether the request was successfully sent to the Kafka reliable delivery transport - an acknowledgement is received from Kafka before replying */
      sent?: boolean;
      /** @description Identifier of the Kafka message that has been acknowledged as received by the reliable delivery transport */
      msg?: string;
    };
    EthconnectNewContractFormData: {
      /** @description Discovery mode: If set then the response will be an array of Solidity files found in the supplied files, rather than attempting the compilation (can also be set as a URL query parameter) */
      findsolidity?: string;
      /** @description Discovery mode: If set then the response will be an array of contract names returned by <code>solc</code> in the compiled output, rather than attempting to install the REST API (can also be set as a URL query parameter) */
      findcontracts?: string;
      /** @description If a zip/tarball is supplied containing multiple solidity files, this field is required to set the Solidity source code file to compile (can also be set as a URL query parameter). Use <code>findsolidity</code> to find possible values. */
      source?: string;
      /** @description If the compilation results in multipel contracts, this field is required to set the contract name to use when deploying contracts via the factory methods (can also be set as a URL query parameter). Use <code>findcontracts</code> to find possible values. */
      contract?: string;
      /**
       * Format: binary 
       * @description Any other properties should be file-content: .sol .zip .tar .tgz .tar.gz .tar.bz2 files are supported
       */
      "*"?: string;
    };
    EthconnectABI: {
      /**
       * Format: date-time 
       * @description The date the ABI was installed into the REST API Gateway
       */
      created?: string;
      /** @description The ID of the ABI deployment */
      id?: string;
      /** @description The description of the ABI extracted from the devdocs of the Solidity */
      description?: string;
      /** @description The base path of the ABI resource on the REST API Gateway API */
      path?: string;
      /** @description Whether full bytecode for deployment of the contract has been supplied, so the API can be used as a factory */
      deployable?: boolean;
      /** @description Full URL to query the OpenAPI 2.0 (Swagger) interface of the REST API generated for the ABI */
      openapi?: boolean;
      /** @description The compilerVersion used to compile the ABI and deployable bytecode */
      compilerVersion?: boolean;
    };
    EthconnectABIs: (components["schemas"]["EthconnectABI"])[];
    EthconnectEventStreamCreate: {
      /**
       * @description The type of event stream 
       * @enum {string}
       */
      type?: "webhook" | "websocket";
      /**
       * @description The number of events to attempt to batch together before delivery 
       * @default 1
       */
      batchSize?: number;
      /**
       * @description The number of milliseoconds to wait to fill the batchSize before delivery 
       * @default 5000
       */
      batchTimeoutMS?: number;
      /**
       * @description Amount of time to perform exponential backoff retry for if the endpoint is unable to process a message, before either failing the batch, or entrying blocked state (0 means no backoff retry) 
       * @default 0
       */
      retryTimeoutSec?: number;
      /**
       * @description Error handling mode defines whether to discard events and move onto the next batch if they cannot be processed after the retryTimeoutSec configured retry interval, or enter a blocked state retrying the batch indefinitely 
       * @enum {string}
       */
      errorHandling?: "block" | "skip";
      /**
       * @description If configured to block indefinitely to deliver events, this is the long retry that comes into effect after any exponential backoff retry period 
       * @default 30
       */
      blockedReryDelaySec?: number;
      /** @description Configuration options specific to type 'webhook' */
      webhook?: {
        /** @description The URL to deliver batches to */
        url?: string;
        /** @description Custom headers to pass to the URL, such as an API Key */
        headers?: Record<string, never>;
        /** @description Set when using TLS encrypted HTTPS connections to invoke a test endpoint, that does not have a verifiable certificate (self-signed, or not matching the hostname in the URL) */
        tlsSkipHostVerify?: boolean;
        /** @description Maximum time to allow for the endpoint to respond to each request */
        requestTimeoutSec?: number;
      };
      /** @description Configuration options specific to type `websocket` */
      websocket?: {
        /** @description The topic to which websocket clients should listen to receive events for this Event Stream */
        topic?: string;
      };
    };
    EthconnectEventStream: components["schemas"]["EthconnectEventStreamCreate"] & {
      /**
       * Format: date-time 
       * @description The date the Event Stream was installed into the REST API Gateway
       */
      created?: string;
      /** @description The ID of the Event Stream */
      id?: string;
      /** @description The resource path of the Event Stream */
      path?: string;
      /** @description Whether the event stream is currently suspended */
      suspended?: boolean;
    };
    EthconnectEventStreams: (components["schemas"]["EthconnectEventStream"])[];
    EthconnectSubscription: {
      /** @description The ID of the Event Stream to which this Subscription delivers messages */
      stream?: string;
      /** @description The first block from which to deliver messages - use 'latest' to subscribe from the current block */
      fromBlock?: string;
    };
    EthconnectFullSubscription: components["schemas"]["EthconnectSubscription"] & {
      /**
       * Format: date-time 
       * @description The date the Subscription was registered in the REST API Gateway
       */
      created?: string;
      /** @description The ID of the Subscription */
      id?: string;
      /** @description The resource path of the Subscription */
      path?: string;
      /** @description Descriptive name of the subscription generated from the registered event signature <code>ContractAddr:EventName(type1,type2)</code> */
      name?: string;
      /** @description The ID of the Event Stream to which this Subscription delivers messages */
      stream?: string;
      /** @description The first block from which to generate */
      fromBlock?: string;
      /** @description Details of the addresses and topics this filter is registered against */
      filter?: Record<string, never>;
      /** @description ABI event details */
      event?: Record<string, never>;
    };
    EthconnectSubscriptions: (components["schemas"]["EthconnectFullSubscription"])[];
  };
  responses: {
    /** @description Application Credential Not Found */
    NotFound: never;
    /** @description Internal Error */
    InternalError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
  parameters: {
    /** @description The ID of the Event Stream */
    EthconnectStreamID: string;
    /** @description The ID of the Subscription */
    EthconnectSubscriptionID: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export type operations = Record<string, never>;
